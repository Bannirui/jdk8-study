# java并发

> wait、notify

* wait
    * 当调用对象的wait方法时，必须确保调用wait方法的这个线程已经持有了这个对象的monitor监视器锁
    * 调用对象的wait方法后，该线程就会释放掉该对象的监视器锁，然后进入等待状态，进入了monitor的wait set
    * 当线程调用wait后进入等待状态时，它就可以等待其他线程调用相同对象的notify或者notifyAll方法使自己被唤醒
    * 一旦这个线程被其他线程唤醒后，该线程就会与其他线程一起开始竞争这个对象的锁，公平竞争，只有当该线程获取到这个对象的锁之后，线程才会继续往下执行
    * 调用Thread的sleep方法时，线程并不会释放掉对象的锁
    * 调用wait方法的代码片段需要放在一个synchronized块或者synchronized方法中，这样才可以保证线程在调用wait方法之前已经获取到了对象的锁
*  notify
    * 当调用对象的notify方法使，它会随机唤醒这个对象等待集合wait set中的任意一个线程，当某个线程被唤醒之后，它就会与其他线程公平竞争对象的锁
    * 当调用对象的notifyAll方法时，它会唤醒该对象等待集合wait set中的所有线程，这些线程被唤醒之后，又会和其他线程一起公平竞争对象的锁
    * 在某一个时刻，只有一个线程可以拥有对象的锁
    
> synchronized

* 修饰代码块	
    * 使用synchronized修饰代码块时字节码层面上是通过monitorenter和monitorexit指令来实现锁的获取与释放动作
    * 当线程进入到monitorenter指令后，线程会持有Monitor对象，退出monitorenter指令后，线程会释放Monitor对象
* 修饰方法
    * 对于synchronized关键字修饰方法来说，并没有出现monitorenter和monitorexit指令，而是出现了一个ACC_SYNCHRONIZED标志
    * JVM使用了ACC_SYNCHRONIZED访问标志区分一个方法是否为同步方法：当方法被调用时，调用指令会检查该方法是否拥有ACC_SYNCHRONIZED标志，如果有，那么执行线程将会先持有该方法所在对象的Monitor对象，然后方法执行期间，其他任何线程都无法再获取到这个Monitor，当线程执行完这个方法后，它会释放掉这个Monitor对象
* JVM中的同步是基于进入与退出监视器对象(管程对象)(Monitor)来实现的，每个对象实例都会有一个Monitor对象，Monitor对象会和Java对象一同创建并销毁，Monitor对象是由C++来实现的
* 当多个线程同时访问一段同步代码时，这些线程会被放到一个EntryList集合中，处于阻塞状态的线程都会被放到这个列表当中。接下来，当线程获取到对象的Monitor时，Monitor是依赖于底层操作系统的mutex lock来实现互斥的，线程获取mutex成功，则会持有该mutex，这时其他线程就无法再获取到该mutex
* 如果线程调用了wait方法，那么该线程就会释放掉所持有的mutex，并且该线程会进入到waitSet等待集合中，等待下一次被其他线程调用notify/notifyAll唤醒。如果当前线程顺利执行完毕方法，那么它也会释放掉所持有的mutex
* 同步锁在这种实现方式当中，因为Monitor是依赖底层的操作系统的实现，这样就存在用户态和内核态之间的切换，所以会增加性能开销
* 通过对象互斥锁的概念来保证共享数据操作的完整性，每个对象都对应一个可成为互斥锁的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象
* 那些处于EntryList(阻塞队列)与WaitSet(等待集合)中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在linux下是通过pthread_mutex_lock函数来实现的。线程被阻塞之后便会进入到内核调度状态，这会导致系统在用户态和内核态之间来回切换，严重影响锁的性能
* 解决上述问题的办法是自旋(Spin)。其原理是：当发生对Monitor的竞争时，如果Owner能够在很短的时间内释放掉锁，则那些正在争用的线程就可以稍微等待一下，所谓的自旋，在Owner线程释放掉锁之后，争用线程可能会立即获取到锁，从而避免了系统阻塞。不过，当Owner运行的时间超过了临界值后，争用线程自旋一段时间之后依然无法获取到锁，这时争用线程就会停止自旋而进入到阻塞状态。所以总体的思想是：先自旋，不成功再进行阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有很大的性能提升。显然，自旋在多处理器(多核心)上才有意义
* 互斥锁的属性
    * PTHREAD_MUTEX_TIMED_NP：这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种策略可以确保资源分配的公平性
    * PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁。允许一个线程对同一个锁成功获取多次，并通过unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新进行竞争
    * PTHREAD_MUTEX_ERRORCHECK_NP：检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同，这样就保证了当不允许多次加锁时不会出现最简单情况下的死锁
    * PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争
    